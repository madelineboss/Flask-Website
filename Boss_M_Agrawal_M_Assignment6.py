"""
Name: Madeline Boss, Mahi Agrawal
<<<<<<< HEAD
Date: 11/13/25
Assignment: 5
Due Date: November 20, 2025
=======
Date: 11/28/25
Assignment: 6
Due Date: December 4, 2025
>>>>>>> Madeline2.0
About this project: The goal of this project is to develop a web app with a web frontend and a database backend for small 
scale real-world applications using Flask and Python
Assumptions: Provided code from professor works.
All work below was performed solely by Madeline Boss and Mahi Agrawal.
I did not use code generated by an AI tool.
"""

import sqlite3
import os
#from Cryptodome.Cipher import AES
#for vscode:
from Crypto.Cipher import AES
#for linprog:
#from Cryptodome.Ciper import AES
import  string,base64
from flask import Flask, render_template, request, session, redirect, url_for
app = Flask(__name__)

app.secret_key = "baking-contest-key"
db_path = os.path.join(os.path.dirname(__file__), 'assignment5.db')

@app.after_request
def add_no_cache_headers(response):
	response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
	response.headers['Pragma'] = 'no-cache'
	response.headers['Expires'] = '0'
	return response

class AESCipher(object):
    def __init__(self, key,iv):
        self.key = key
        self.iv = iv

    def encrypt(self, raw):
        self.cipher = AES.new(self.key, AES.MODE_CFB,self.iv)
        ciphertext = self.cipher.encrypt(raw)
        encoded = base64.b64encode(ciphertext)
        return encoded

    def decrypt(self, raw):
        decoded = base64.b64decode(raw)
        self.cipher = AES.new(self.key, AES.MODE_CFB,self.iv)
        decrypted = self.cipher.decrypt(decoded)
        return str(decrypted, 'utf-8')

def init_db():
	key = b'BLhgpCL81fdLBk23HkZp8BgbT913cqt0'
	iv = b'OWFJATh1Zowac2xr'
	cipher = AESCipher(key,iv)

	# connecting to database
	conn = sqlite3.connect(db_path)
	# creating cursor to execute queries
	cur = conn.cursor()

	# drop tables
	cur.execute("DROP TABLE IF EXISTS users")
	cur.execute("DROP TABLE IF EXISTS results")
	cur.execute("DROP TABLE IF EXISTS entries")
	conn.commit()


	# creating the users table if it does not already exist
	cur.execute('''CREATE TABLE IF NOT EXISTS users(
	userID INTEGER PRIMARY KEY AUTOINCREMENT,
	Name TEXT NOT NULL,
	Age INTEGER NOT NULL,
	PhoneNum TEXT NOT NULL,
	SecLvl INTEGER NOT NULL,
	Password TEXT NOT NULL
	);''')
	conn.commit()
	cur.execute('''CREATE TABLE IF NOT EXISTS results(
			 EntryID INTEGER NOT NULL, 
			 UserID INTEGER NOT NULL, 
			 BakedItem TEXT NOT NULL,
			 ExcelVotes INTEGER NOT NULL, 
			 OkayVotes INTEGER NOT NULL, 
			 BadVotes INTEGER NOT NULL);
	''')


	# insert initial users for testing purposes
	cur.execute("SELECT * FROM users")
	existing = cur.fetchone()

	if existing is None: # only insert if not already present
		initial_users = [
	        ("Tom",   22, "1231231111", 3, "admin"),
	        ("Alice", 30, "5551112222", 1, "alicepw"),
	        ("Bob",   45, "5553334444", 2, "bobpw")
	    ]
		
		for name, age, phone, sec, pw in initial_users:
			eName = cipher.encrypt(name.encode("utf-8"))
			ePhone = cipher.encrypt(phone.encode("utf-8"))
			ePw = cipher.encrypt(pw.encode("utf-8"))

			cur.execute(
				"INSERT INTO users (Name, Age, PhoneNum, SecLvl, Password) VALUES (?, ?, ?, ?, ?)",
				(eName, age, ePhone, sec, ePw)
			)

		conn.commit()


	# creating the entries table if it does not already exist
	cur.execute('''CREATE TABLE IF NOT EXISTS entries(
			entryID INTEGER PRIMARY KEY AUTOINCREMENT, 
			userName TEXT NOT NULL, 
			item TEXT NOT NULL, 
			excellent INTEGER NOT NULL, 
			ok INTEGER NOT NULL, 
			bad INTEGER NOT NULL);''')
	conn.commit()


	# initiate initial entries for testing purposes
	cur.execute("SELECT * FROM entries")
	existing = cur.fetchone()

	if existing is None: # only insert if not already present
	    entries = [
	        ("Tom",   "Pumpkin Pie",        5, 0, 0),
	        ("Alice", "Cupcakes",           3, 1, 0),
	        ("Bob",   "Chocolate Cake",     4, 2, 1)
	    ]

	    cur.executemany(
	        "INSERT INTO entries (userName, item, excellent, ok, bad) VALUES (?, ?, ?, ?, ?)",
	        entries
	    )
	    conn.commit()

	for row in cur.execute("SELECT rowid, userName FROM entries"):
		print(repr(row))
	conn.close()

def get_db():
	conn = sqlite3.connect(db_path)
	conn.row_factory = sqlite3.Row
	return conn

# homepage
@app.route('/')
def home():
	if not session.get('logged_in'):
		return render_template('login.html')

	return render_template('home.html', username=session['username'], security=session['security'])

# login page
@app.route('/login', methods=['GET', 'POST'])
def login():
	if request.method == 'GET':
		return render_template('login.html')

	elif request.method == 'POST':

		# get input values from html form
		username = request.form.get("username", "").strip()
		password = request.form.get("password", "").strip()
		key = b'BLhgpCL81fdLBk23HkZp8BgbT913cqt0'
		iv = b'OWFJATh1Zowac2xr'
		cipher = AESCipher(key,iv)

		encrypt_user = cipher.encrypt(username.encode("utf-8"))
		encrypt_pass = cipher.encrypt(password.encode('utf-8'))

		# validate username and password against user database
		conn = get_db()
		cur = conn.cursor()
		cur.execute("SELECT * FROM users WHERE Name=? AND Password=?", (encrypt_user, encrypt_pass))
		user = cur.fetchone()
		conn.close()

		if user == None:
			return render_template('login.html', error="Invalid username and/or password!")
		else:
			print("Before login:", session)
			session['logged_in'] = True
			session['username'] = cipher.decrypt(user['Name'])
			session['security'] = user['SecLvl']
			print("After login: ", session)

			return redirect(url_for('home'))

# add new baking contest user
@app.route('/addNewUser', methods=['GET', 'POST'])
def addNewUser():
	if not session.get('logged_in'):
		return render_template('login.html')
	
	if session.get('security') != 3:
		not_found_msg = ["The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again."]
		return render_template('not-found.html', message=not_found_msg)
		
	if request.method == 'GET':
		return render_template('new-baking-user.html')

	elif request.method == 'POST':

		# get input values from html form
		name = request.form.get("name", "").strip()
		age = request.form.get("age", "").strip()
		phoneNum = request.form.get("phone", "").strip()
		securityLevel = request.form.get("security", "").strip()
		password = request.form.get("password", "").strip()

		# validate input values
		error_messages = []

		if name == "":
			error_messages.append("You can not enter an empty name.")
		if not age.isdigit():
			error_messages.append("Age must be a whole number.")
		else:
			age = int(age)
			if age <= 0 or age >= 121:
				error_messages.append("Age must be greater than 0 and less than 121.")
		if phoneNum == "":
			error_messages.append("You can not enter enter an empty phone number.")
		if not securityLevel.isdigit():
			error_messages.append("Security level must be a whole number.")
		else:
			securityLevel = int(securityLevel)
			if securityLevel < 1 or securityLevel > 3:
				error_messages.append("Security level must be between 1 and 3.")
		if password == "":
			error_messages.append("You can not enter an empty password.")

		# if error messages exist, print them on the results page
		if error_messages:
			return render_template('results.html', message=error_messages)

		#encryption
		key = b'BLhgpCL81fdLBk23HkZp8BgbT913cqt0'
		iv = b'OWFJATh1Zowac2xr'
		cipher = AESCipher(key,iv)

		encryptedName = cipher.encrypt(name.encode("utf-8"))
		encryptedPhone = cipher.encrypt(phoneNum.encode("utf-8"))
		encryptedPass = cipher.encrypt(password.encode("utf-8"))
		# add new user into database using a parameterized query
		conn = sqlite3.connect(db_path)
		cur = conn.cursor()
		cur.execute(
			"INSERT INTO users (Name, Age, PhoneNum, SecLvl, Password) VALUES (?, ?, ?, ?, ?)",
			(encryptedName, age, encryptedPhone, securityLevel, encryptedPass)
		)
		conn.commit()
		conn.close()

		# return success message (THE RESULTS PAGE IS THE SUCCESS/ERROR MESSAGES)
		return render_template('results.html', message=["User added successfully."])


# list baking contest users
@app.route('/listUsers')
def listUsers():
	if not session.get('logged_in'):
		return render_template('login.html')
	
	if session.get('security') < 2:
		not_found_msg = ["The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again."]
		return render_template('not-found.html', message=not_found_msg)
	
	conn = get_db()
	cur = conn.cursor()
	cur.execute('SELECT * from users')
	users_encrypt = cur.fetchall()
	conn.close()
	#decryption
	key = b'BLhgpCL81fdLBk23HkZp8BgbT913cqt0'
	iv = b'OWFJATh1Zowac2xr'
	cipher = AESCipher(key,iv)

	#decrypted users list
	users_decrypt = []
	for u in users_encrypt:
		users_decrypt.append({
			'Name': cipher.decrypt(u['Name']),
			'Age': u['Age'],
			'PhoneNum': cipher.decrypt(u['PhoneNum']),
			'SecLvl': u['SecLvl'],
			'Password': cipher.decrypt(u['Password'])
		})
	return render_template('list-baking-users.html', users = users_decrypt)


# list baking contest results
@app.route('/listResults')
def listResults():
	if not session.get('logged_in'):
		return render_template('login.html')
	
	if session.get('security') != 3:
		not_found_msg = ["The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again."]
		return render_template('not-found.html', message=not_found_msg)
	
	conn = get_db()
	cur = conn.cursor()
	cur.execute("SELECT COUNT(*) FROM results")
	count = cur.fetchone()[0]
	result = []
	if count == 0:
		result = [('1', '1', 'Whoot Whoot Brownies', '1', '2', '4'),
			 ('2', '2', 'Cho Chip Cookies', '4', '1', '2'), 
			 ('3', '3', 'Cho Cake', '2', '4', '1'),
			 ('4', '1', 'Sugar Cookies', '2', '2', '1')]
		cur.executemany('Insert Into results Values (?,?,?,?,?,?)', result)
		conn.commit()
	
	#fetching data
	cur.execute("SELECT * FROM entries")
	results = cur.fetchall()
	conn.close()
	return render_template('list-results.html', results=results)

# logout
@app.route('/logout')
def logout():
	session.clear()
	return redirect(url_for('login'))

@app.route('/new-entry', methods=['GET', 'POST'])
def newEntry():
	#checking for correct log in
	if not session.get('logged_in'):
		return render_template('login.html')
	
	if request.method == 'GET':
		return render_template('new-entry.html')
	
	elif request.method == 'POST':
		#grabbing input vals from the web page
		bakingItem = request.form.get("nameItem", "").strip()
		excellent = request.form.get("excelVote", "").strip()
		ok = request.form.get("okVotes", "").strip()
		bad = request.form.get("badVotes", "").strip()

		#valitading user inputs
		error_msgs = []

		if bakingItem == "":
			error_msgs.append("You cannot enter an empty name of baking item.")
		
		if not excellent.isdigit():
			error_msgs.append("Number of excellent votes must be a whole number.")

		else:
			excellent = int(excellent)
			if excellent < 0:
				error_msgs.append("Number of excellent votes cannot be less than zero.")
		
		if not ok.isdigit():
			error_msgs.append("Number of OK votes must be a whole number.")

		else:
			ok = int(ok)
			if ok < 0:
				error_msgs.append("Number of OK votes cannot be less than zero.")

		if not bad.isdigit():
			error_msgs.append("Number of bad votes must be a whole number.")

		else:
			bad = int(bad)
			if bad < 0:
				error_msgs.append("Number of bad votes cannot be less than zero.")

		if error_msgs:
			return render_template('results.html', message=error_msgs)
	
		
		conn = sqlite3.connect(db_path)
		cur = conn.cursor()
		cur.execute(
			"INSERT INTO entries (userName, item, excellent, ok, bad) VALUES (?, ?, ?, ?, ?)",
			(session['username'], bakingItem, excellent, ok, bad)
		)
		conn.commit()
		conn.close()
		print("POST /new-entry received:")
		print("bakingItem:", repr(bakingItem))
		print("excellent:", repr(excellent))
		print("ok:", repr(ok))
		print("bad:", repr(bad))

		if error_msgs:
			print("Validation errors:", error_msgs)
			return render_template(results.html, message=error_msgs)
		return render_template('results.html', message = ["Baking contest entry successfully added."])

@app.route('/my-results')
def myResults():
	if not session.get('logged_in'):
		return render_template('login.html')
	print("1. SESSION AT /my-results:", session)
	username = session['username'].strip()
	print(f"session username: {username}")
	conn = sqlite3.connect(db_path)
	conn.row_factory = sqlite3.Row
	cur = conn.cursor()
	cur.execute("SELECT * FROM entries WHERE userName = ?",
			 (username, ))
	user_entries = cur.fetchall()
	for u in user_entries:
		print(u)
		print("check")
	print("Entries for user after insert:", cur.fetchall())
	print("2.SESSION AT /my-results", session)
	conn.close()
	return render_template('my-results.html', entries=user_entries)


@app.route('/results')
def results():
	return render_template('results.html')

@app.route('/not-found')
def notFound():
	return render_template('not-found.html')

if __name__ == '__main__':
	init_db()
	app.run(host='127.0.0.1', port=50000)
	# visit http://127.0.0.1:50000 to see website
